<?php

namespace Smuuf\Primi;

use hafriedlander\Peg\Parser;

class CompiledParser extends Parser\Packrat {

	// Add these properties so PHPStan doesn't complain about undefined properties.

	/** @var int **/
	public $pos;

	/** @var string **/
	public $string;

/*!* Primi

# Previous StringLiteral regex causing PREG_JIT_STACKLIMIT_ERROR
# StringLiteral: /"(.|\n)*?"|'(.|\n)*?'/

# Carefully crafted (or stolen somewhere) string matching regex which supports
# both " and ' quotes, doesn't cause JIT stack overflow and also supports escaped quotes.
StringLiteral: / (?:".*?(?<!\\)")|(?:'.*?(?<!\\)') /s
NumberLiteral: /-?\d+(\.\d+)?/
BoolLiteral: "true" | "false"
NullLiteral: "null"
RegexLiteral: "/" /(\\\/|[^\/])+/ "/"
Nothing: ""

Literal: skip:NumberLiteral | skip:StringLiteral | skip:BoolLiteral | skip:NullLiteral | skip:RegexLiteral
VariableName: / ([a-zA-Z_][a-zA-Z0-9_]*) /
Variable: ( pre:UnaryOperator core:VariableName ) | ( core:VariableName post:UnaryOperator ) | core:VariableName
Property: skip:VariableName
AnonymousFunction: "function" __ "(" __ args:FunctionDefinitionArgumentList? __ ")" __ body:Block | "(" __ args:FunctionDefinitionArgumentList? __ ")" __ "=>" __ body:Block

ArrayItem: ( key:Expression __ ":" )? __ value:Expression )
ArrayDefinition: "[" __ ( items:ArrayItem ( __ "," __ items:ArrayItem )* )? __ ( "," __ )? "]"

Value: skip:Literal | skip:Variable | skip:ArrayDefinition
VariableVector: core:Variable vector:Vector
Vector: ( "[" __ ( arrayKey:Expression | arrayKey:Nothing ) __ "]" | propKey:PropertyAccess) vector:Vector?
Mutable: skip:VariableVector | skip:VariableName
PropertyAccess: ObjectResolutionOperator skip:Property

ObjectResolutionOperator: "."
AddOperator: "+" | "-"
MultiplyOperator: "*" | "/"
AssignmentOperator: "="
ComparisonOperator: "==" | "!=" | ">=" | "<=" | ">" | "<"
UnaryOperator: "++" | "--"

Expression: skip:AnonymousFunction | skip:Assignment | skip:Comparison | skip:Addition
Comparison: left:Addition __ op:ComparisonOperator __ right:Addition
Assignment: left:Mutable __ op:AssignmentOperator __ right:Expression
Addition: operands:Multiplication ( __ ops:AddOperator __ operands:Multiplication)*
Multiplication: operands:Operand ( __ ops:MultiplyOperator __ operands:Operand)*
Operand: ( ( "(" __ core:Expression __ ")" | core:Value ) chain:Chain? ) | skip:Value
Chain: ( core:Dereference | core:Invocation | core:PropertyGetter ) chain:Chain?
PropertyGetter: key:PropertyAccess
Dereference: "[" __ key:Expression __ "]"
Invocation: "(" __ args:ArgumentList? __ ")"

ArgumentList: args:Expression ( __ "," __ args:Expression )*

FunctionDefinitionArgumentList: skip:VariableName ( __ "," __ skip:VariableName )*
FunctionDefinition: "function" [ function:VariableName __ "(" __ args:FunctionDefinitionArgumentList? __ ")" __ body:Block

IfStatement: "if" __ "(" __ left:Expression __ ")" __ ( right:Block )
WhileStatement: "while" __ "(" __ left:Expression __ ")" __ ( right:Block )
ForeachStatement: "foreach" __ "(" __ left:Expression __ "as" __ item:VariableName __ ")" __ ( right:Block )
CommandStatements: skip:EchoStatement | skip:ReturnStatement
EchoStatement: "echo" [ subject:Expression
ReturnStatement: "return" ( [ subject:Expression )?

# &/[A-Za-z]/ Ensures that no sub-rules will be even tried if the string does not start with a letter.
# And we know that our block statements always start with a letter.
BlockStatements: &/[A-Za-z]/ ( skip:IfStatement | skip:WhileStatement | skip:ForeachStatement | skip:FunctionDefinition )

# !/[\s\{\};]/ Ensures that we won't try to match further if any of those symbols are at the beginning of the substring we're matching.
Statement: !/[\s\{\};]/ ( skip:BlockStatements | skip:CommandStatements | skip:Expression )
Block: "{" __ ( skip:Program )? "}"

# Matches any optional whitespace or newline.
__: / [\s\n]* /

# Matches newline, takes care of optional // comments at EOL.
NL: / (?:\/\/[^\n]*)?\n /

# Statement separator: Newline or semicolon.
SEP: ";" | NL

# "!/$/" Ensures we won't try to find statements at EOF.
Program: ( !/$/ __ Statement? > SEP )+ __

*/

}
