#!/usr/bin/env php
<?php

// Composer's autoload.

use \Smuuf\Primi\Repl;
use \Smuuf\Primi\Statistics;
use \Smuuf\Primi\Interpreter;
use \Smuuf\Primi\Ex\BaseException;

require __DIR__ . "/vendor/autoload.php";

error_reporting(E_ALL);
set_error_handler(function($severity, $message, $file, $line) {
	throw new \ErrorException($message, 0, $severity, $file, $line);
}, E_ALL);

set_exception_handler(function($ex) {
	echo "PHP ERROR: " . get_class($ex);
	echo ": {$ex->getMessage()} @ {$ex->getFile()}:{$ex->getLine()}\n";
	echo $ex->getTraceAsString() . "\n";
});

// Autoloader.
$loader = new \Smuuf\Koloader\Autoloader(__DIR__ . "/temp/");
$loader->addDirectory(__DIR__ . "/src")->register();

$config = parse_arguments($argv);

if ($config['print_process_stats']) {
	register_shutdown_function(function() {
		$mb = round(memory_get_peak_usage() / 1e6, 4);
		echo "Memory peak: " . $mb. " MB\n";
	});
}

// Determine the source. Act as REPL if no source was specified.
if (empty($config['input'])) {

	echo header_string('REPL');

	$i = new Interpreter;
	$repl = new Repl;
	$repl->start($i->getContext());
	die;

}

if ($config['input_is_code']) {

	// Input is passed as a string of Primi source code.
	$source = $config['input'];

} else {

	// Input is passed as a filename of file containing Primi source code.
	$filepath = $config['input'];
	if (!is_file($filepath)) {
		die("Input file '$filepath' not found.\n");
	}

	$source = file_get_contents($filepath);

}

// Create interpreter - with cache.
$interpreter = new Interpreter(null, __DIR__ . "/temp/");
$scope = $interpreter->getCurrentScope();

// Get syntax tree.
if ($config['tree']) {
	print_r($interpreter->getSyntaxTree($source));
	die;
}

// Run interpreter and catch any error that may have occurred.
try {
	$interpreter->run($source);
} catch (BaseException $e) {
	die("{$e->getMessage()}\n");
}

if ($config['print_scope']) {
	foreach ($scope->getVariables() as $name => $value) {
		echo "$name: {$value->getStringRepr()}\n";
	}
	die;
}

function parse_arguments(array $args): array {

	// Get rid of the first './primi' script argument.
	array_shift($args);

	$config = [
		'tree' => false,
		'print_scope' => false,
		'input_is_code' => false,
		'input' => false,
		'print_process_stats' => false
	];

	while ($a = array_shift($args)) {
		switch ($a) {
			case "-h":
			case "--help":
				die_with_help();
			break;
			case "-t":
			case "--tree":
				$config['tree'] = true;
			break;
			case "-s":
			case "--source":
				$config['input_is_code'] = true;
			break;
			case "-ps":
			case "--print-scope":
				$config['print_scope'] = true;
			break;
			case "-st":
				case "--stats":
					$config['print_process_stats'] = true;
				break;
			default:
				$config['input'] = $a;
			break;
		}
	}

	return $config;

}

function die_with_help() {

	$header = header_string('CLI');
	$help = <<<HELP
$header
Usage: primi [<options>] [<input file>]
Options:
  -t, --tree
    Only print syntax tree and exit.
  -s, --source
    Treat <input file> as string instead of a source file path.
  -ps, --print-scope
    Print contents of global scope after execution.
  -st, --stats
    Print interpreter stats upon exit.

HELP;

	die($help);

}

function header_string(string $env = null) {
	$env = $env ? "($env)" : null;
	return "Primi language {$env}, Copyright (c) Premysl Karbula\n";
}
